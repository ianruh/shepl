#!/bin/zsh

########### Constants ###############

# The profile passed to sandbox-exec on MacOS when executing commands
MACOS_SANDBOX_PROFILE="(version 1) (allow default) (deny file-write*) (allow file-read*)"

# The default shell used when executing commands
EXEC_SHELL="/bin/bash"

# If unsafe exec should be allowed
UNSAFE=false

# If the command should be echoed instead of executed when done
ECHO=false

############### Process all the arguments ##################

# Because we call shepl recursively, keep track of all the flags passed
original_flags=""

# The pattern is to loop until no option/argument patterns match
while true; do

if [[ "$1" =~ '^(-h|--help)$' ]]; then
cat << END_HELP
Usage: shepl [options] [default]

A shell repl for rapid exploration & prototyping of commands. Pipe input to it,
rapidly iterate on your command, and then return the output when done.

If you find yourself working with one tool a lot and don't want to type a couple
extra characters, you can easily setup an alias using the default command:
    
    $ alias jq-repl="shepl jq -C"
    $ cat example.json | jq-repl

Options:
    --echo|-e      Echo the constructed commanded instead of executing
    --help|-h      Show this help message
    --shell path   Path of the shell command to use. Default /bin/bash
    --unsafe       Allow unsafe shell execution

Key Bindings:
    enter          Confirm the current command
    ctrl-/         Show this help message in the preview window
    ctrl-u         Scroll the preview window half page up
    ctrl-d         Scroll the preview window half page down
    ctrl-r         View history
    tab            Scroll to next history item
    shift-tab      Scroll to preview history item
    alt-enter      Replace command with focused command from history
    alt-bspace     Clear the current command

    [Default FZF bindings including...]
    ctrl-c         Exit

Example:

    Quickly select a subset of fields from a JSON file by piping it through shepl
    and constructing a jq query in real time. When you are happy with the query,
    confirm the command, and the output will be written to selection.json.
    
        $ cat example.json | shepl > selection.json

    Prototype a regex expression by piping your input to shepl and using grep, rg,
    or your choice of engine, and seeing the output live as you type. Using the
    -e option, you can copy the final command to your clipboard when you are done.

        $ cat lotr.txt | shepl -e | pbcopy
        $ pbpaste
        rg '.*Bilbo said.*' 

Internal Options:
    --exec inputfile command...   Execute the given command, with inputfile piped
                                  to it in a jail.

Jailing:
    
    Jails are implemented differently depening on the system. They aren't true jails
    and should not be trusted. They are intended as a first line of defence against
    accidentally destroying your system.

    MacOS - Using sandbox-exec
END_HELP
return

# Check if we should echo or execute
elif [[ "$1" =~ '^(-e|--echo)$' ]]; then
    ECHO=true
    original_flags=" '$1'"
    shift

# Set the shell path if provided (should follow the flag)
elif [[ "$1" =~ '^--shell$' ]]; then
    EXEC_SHELL="$2"
    original_flags=" '$1' '$2'"
    shift 2

# Set if unsafe exec should be allowed
elif [[ "$1" =~ '^--unsafe$' ]]; then
    UNSAFE=true
    original_flags=" '$1'"
    shift

# If nothing has matched, then we are done with options, so break the loop
else
    break
fi

done # Options while loop

########### Command Execution #############
# Handle this outside of the options loop as it is kinda a special case

# Execute the command in a jail
if [[ "$1" =~ '^--exec$' ]]; then
    # Pop the flag off
    shift

    # Grab the input file name
    local inputfile="$1"
    shift

    # Detect the system type. If unsafe, do that.
    if [[ "$UNSAFE" == true ]]; then 
        cat "$inputfile" | eval "$@"
    elif [[ $(uname -s) =~ '.*Darwin.*' ]]; then
        cat "$inputfile" | sandbox-exec -p "$MACOS_SANDBOX_PROFILE" "$EXEC_SHELL" -c "$@"
    else
        echo "No safe exec implemented. Retry with --unsafe flag."
        return 1
    fi

    return 0
fi

########## Main Program ############

# The history file where past commands are written
mkdir -p "$HOME/.cache/"
local historyfile="$HOME/.cache/shepl"
touch "$historyfile"

# Capture the stdin and write to a file
local inputfile=$(mktemp)
cat /dev/stdin > "$inputfile" &

# Flatten the default argument & escape it
local flat_default=""
for arg in ${@}; do
    flat_default="$flat_default $(printf "%q" "$arg")"
done

# Abuse FZF for the windowing system...
local command=$(echo | fzf \
    --preview-window 'up:99%' \
    --history "$historyfile" \
    --no-info \
    --query "$flat_default " \
    --prompt '> ' \
    --header 'Construct your command. Enter to finish. Ctrl-/ for help.' \
    --preview "shepl $original_flags --exec '$inputfile' {q}" \
    --bind 'ctrl-u:preview-half-page-up,ctrl-d:preview-half-page-down' \
    --bind 'tab:up,shift-tab:up' \
    --bind 'alt-enter:replace-query,alt-bspace:clear-query' \
    --bind 'enter:execute(echo {q})+abort' \
    --bind "ctrl-/:preview(shepl --help)" \
    --bind "alt-/:preview(shepl --help)" \
    --bind "ctrl-r:reload(cat "$historyfile")+change-preview-window(up:80%)+enable-search" \
    --pointer ' ' \
    --disabled \
    --cycle \
)
# If command is empty, then fzf was aborted, so exit.
if [[ -z "$command" ]]; then
    return
fi

# Echo if requested, otherwise execute
if [[ "$ECHO" == true ]]; then
    echo "$command"
else
    shepl $original_flags --exec "$inputfile" "$command"
fi
